<html>
    <head>
        <!--<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>-->
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
                .modebar{
                  display: none !important;
                }
                text:hover {
                  fill: black;
                }
            </style>
    </head>
    <body>
        <div id="chartDiv1" class="chartDiv" style="max-width: 80%;height: 300px"></div>
    </body>

<script>

function dateToSolrTimestamp(dateString) {
    // Parse the human-readable date string to a Date object.
    var parts = dateString.split('/');

    // Create a date object using UTC values
    var dateObj = new Date(Date.UTC(parts[2], parts[0] - 1, parts[1]));

    // Convert to UNIX timestamp format.
    return dateObj.getTime().toString();
}

async function createGanttChart() {
    const response = await fetch('https://ddsa-labcas-staging.jpl.nasa.gov/labcas-ui/assets/tmp/test-cell-line2.json');
    let data = await response.json();

    const urlParams = new URLSearchParams(window.location.search);
    const cellcode = urlParams.get('cellcode');
    data = data.filter(row => row.MammalianCellCode === cellcode);

  // Map the EventType to colors
  const colorMap = {
    'Start': 'green',
    'Monitor': 'blue',
    'Feed': 'darkblue',
    'Passage': 'orange',
    'Transfer': '#7393B3',
    'Stop': 'red'
  };

  // Sort data by EventDate
  data.sort((a, b) => new Date(a.EventDate) - new Date(b.EventDate));

  let minDate = new Date(data[0].EventDate);
  let maxDate = new Date(data[data.length-1].EventDate);
  let maxWinDate = new Date(minDate);
  maxWinDate.setMonth(minDate.getMonth() + 1);
    if (maxDate>maxWinDate){
        maxDate = maxWinDate;
    }

  const margin = { top: 0, right: 146, bottom: 30, left: 170 },
    width = window.innerWidth - margin.left - margin.right,
    height = 220 - margin.top - margin.bottom;

  const svg = d3.select("#chartDiv1")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
      "translate(" + margin.left + "," + margin.top + ")");

  let x2 = d3.scaleTime()
    .domain(d3.extent(data, d => new Date(d.EventDate)))
    .range([0, width]);
  let x = d3.scaleTime()
    .domain([minDate, maxDate])
    .range([0, width]);

  let xAxis = d3.axisBottom(x).tickFormat(d3.utcFormat("%m/%d/%Y"));

  let gx = svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);

    const zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

  svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "none")
    .style("pointer-events", "all")
    .call(zoom);


  const y = d3.scaleBand()
    .range([0, height])
    .domain(data.map(d => d.MammalianCellCode))
    .padding(.1);

// First, create a nested array where each subarray contains all events occurring on the same date
let nestedData = d3.group(data, d => d.EventDate);

// Then, create an array that maps each date to the total number of events occurring on that date
let counts = Array.from(nestedData, ([key, value]) => [key, value.length]);

// Map each date to an initial y position based on the total number of events occurring on that date
let yPosMapRect = {}, yPosMapLabel = {};
counts.forEach(([key, value]) => {
  yPosMapRect[key] = height - value * 25;  // 20 is the height of each rectangle
  yPosMapLabel[key] = height - value * 25;  // same calculation for labels
});


let tooltip = d3.select("body")
  .append("div")
  .style("position", "absolute")
  .style("visibility", "hidden")
  .style("background", "#F0FFFF")
  .style("color", "white")
  .style("padding", "10px").style("border-radius", "6px");

// Map the EventType to image URLs
const shapeMap = {
  'Start': '/labcas-ui/assets/tmp/start-tall.png',
  'Monitor': '/labcas-ui/assets/tmp/monitor-tall.png',
  'Feed': '/labcas-ui/assets/tmp/feed-tall.png',
  'Passage': '/labcas-ui/assets/tmp/passage-tall.png',
  'Transfer': '/labcas-ui/assets/tmp/transfer-tall.png',
  'Stop': '/labcas-ui/assets/tmp/stop-tall.png'
};

  // Append the MammalianCellCode labels directly
  svg.selectAll(".cellCode")
    .data(data)
    .enter()
    .append("text")
    .attr("class", "cellCode")
    .attr("x", -margin.left)
    .attr("y", d => y(d.MammalianCellCode) + y.bandwidth() / 2)
    .attr("dy", ".35em") // vertical alignment in the middle
    .text(d => d.MammalianCellCode);


    let selectedData = []; // Array to store selected/clicked images' data

// Use yPosMapRect for rectangles
let myRect = svg.selectAll("myRect")
  .data(data)
  .enter()
  .append("image")
  .attr("class", "shape-image")
  .attr("x", d => x(new Date(d.EventDate)))
  .attr("y", d => { let currentY = yPosMapRect[d.EventDate]; yPosMapRect[d.EventDate] += 25; return currentY; })
  .attr("width", 70)
  .attr("height", 27)
  //.attr("fill", d => colorMap[d.EventType])
  .attr("href", d => shapeMap[d.EventType])
  .on("click", function(event, d) {
    if (selectedData.includes(d)) {
      selectedData = selectedData.filter(data => data !== d);
    } else {
      selectedData.push(d);
    }
    updateColorsBasedOnSelection();
    let selectedList = selectedData.map(dataItem => {
      return {
        EventType: dataItem.EventType,
        EventDate: dateToSolrTimestamp(dataItem.EventDate)
      };
    });
    update_virtual_file_table(selectedList);
  })
  .on("mouseover", function(event, d) {
    tooltip.html(`EventType: ${d.EventType}<br/>EventDate: ${d.EventDate}<br/>Notes: ${d.Notes}<br/>InstrumentHandle: ${d.InstrumentHandle}<br/>PreEventCellConcentration: ${d.PreEventCellConcentration}<br/>PostEventCellConcentration: ${d.PostEventCellConcentration}<br/>PostEventCultureVolume: ${d.PostEventCultureVolume} ${d.PostEventCultureVolumeUnits}`)
      .style("visibility", "visible").style("background", colorMap[d.EventType]);
  })
  .on("mousemove", function(event) {
    tooltip.style("top", (event.pageY+10)+"px")
      .style("left",(event.pageX-200)+"px");
  })
  .on("mouseout", function() { tooltip.style("visibility", "hidden"); });


// Use yPosMapLabel for labels
let myLabels = svg.selectAll("myLabels")
  .data(data)
  .enter()
  .append("text")
  .attr("x", d => x(new Date(d.EventDate)) + 33)
  .attr("y", d => { let currentY = yPosMapLabel[d.EventDate]; yPosMapLabel[d.EventDate] += 25; return currentY + 18; })
  .text(d => d.EventType)
  .style("font-size", "12px")
  .style("text-anchor", "middle")
  .attr("fill", "white")
  .attr("class", "shape-image")
  .on("click", function(event, d) {
    if (selectedData.includes(d)) {
      selectedData = selectedData.filter(data => data !== d);
    } else {
      selectedData.push(d);
    }
    updateColorsBasedOnSelection();
    let selectedList = selectedData.map(dataItem => {
      return {
        EventType: dataItem.EventType,
        EventDate: dateToSolrTimestamp(dataItem.EventDate)
      };
    });
    update_virtual_file_table(selectedList);
  })
  .on("mouseover", function(event, d) {
    tooltip.html(`EventType: ${d.EventType}<br/>EventDate: ${d.EventDate}<br/>Notes: ${d.Notes}<br/>InstrumentHandle: ${d.InstrumentHandle}<br/>PreEventCellConcentration: ${d.PreEventCellConcentration}<br/>PostEventCellConcentration: ${d.PostEventCellConcentration}<br/>PostEventCultureVolume: ${d.PostEventCultureVolume} ${d.PostEventCultureVolumeUnits}`)
      .style("visibility", "visible").style("background", colorMap[d.EventType]);
  })
  .on("mousemove", function(event) {
    tooltip.style("top", (event.pageY+10)+"px")
      .style("left",(event.pageX-200)+"px");
  })
  .on("mouseout", function() { tooltip.style("visibility", "hidden"); });

    function zoomed(event) {
    let t = event.transform;
    let xt = t.rescaleX(x2);
    gx.call(xAxis.scale(xt));
    myRect.attr("x", d => xt(new Date(d.EventDate)));
    myLabels.attr("x", d => xt(new Date(d.EventDate)) + 33);
  }


    function updateColorsBasedOnSelection() {
      if (selectedData.length === 0) {
        // If no data is selected, reset all shapes to full opacity
        myRect.attr("opacity", 1);
      } else {
        // Otherwise, only the shapes corresponding to the selected data have full opacity
        myRect.attr("opacity", d => {
          return selectedData.includes(d) ? 1 : 0.4;
        });
      }
    }

    function resetShapes() {
      selectedData = [];
      updateColorsBasedOnSelection();
      update_virtual_file_table([]);
    }

    svg.on("click", function(event) {
      // If the clicked target is not an image shape
      if (!d3.select(event.target).classed("shape-image")) {
        resetShapes();
      }
    });

    function update_virtual_file_table(selected) {
      // Your existing logic here...
      console.log(selected);
        if (window.parent && window.parent.setup_labcas_hierarchy_data) {
            window.parent.setup_labcas_hierarchy_data(localStorage.getItem("hierarchy_file_query"), selected, 0);
        }
    }



}

createGanttChart();

</script>

</html>
